"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"Represents an account in the system, which can be either a user or a contract\n"
type Account {
  """Unique identifier for the account, typically the Ethereum address"""
  id: Bytes!

  """
  Reference to the ERC20Contract if this account is an ERC20 token contract
  """
  asERC20: ERC20Contract

  """List of ERC20 token balances associated with this account"""
  ERC20balances(skip: Int = 0, first: Int = 100, orderBy: ERC20Balance_orderBy, orderDirection: OrderDirection, where: ERC20Balance_filter): [ERC20Balance!]!

  """ERC20 token approvals where this account is the owner"""
  ERC20approvalsOwner(skip: Int = 0, first: Int = 100, orderBy: ERC20Approval_orderBy, orderDirection: OrderDirection, where: ERC20Approval_filter): [ERC20Approval!]!

  """ERC20 token approvals where this account is the spender"""
  ERC20approvalsSpender(skip: Int = 0, first: Int = 100, orderBy: ERC20Approval_orderBy, orderDirection: OrderDirection, where: ERC20Approval_filter): [ERC20Approval!]!

  """ERC20 token transfers where this account is the sender"""
  ERC20transferFromEvent(skip: Int = 0, first: Int = 100, orderBy: ERC20Transfer_orderBy, orderDirection: OrderDirection, where: ERC20Transfer_filter): [ERC20Transfer!]!

  """ERC20 token transfers where this account is the recipient"""
  ERC20transferToEvent(skip: Int = 0, first: Int = 100, orderBy: ERC20Transfer_orderBy, orderDirection: OrderDirection, where: ERC20Transfer_filter): [ERC20Transfer!]!

  """All events emitted by this account"""
  events(skip: Int = 0, first: Int = 100, orderBy: Event_orderBy, orderDirection: OrderDirection, where: Event_filter): [Event!]!
}

input Account_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  asERC20: String
  asERC20_not: String
  asERC20_gt: String
  asERC20_lt: String
  asERC20_gte: String
  asERC20_lte: String
  asERC20_in: [String!]
  asERC20_not_in: [String!]
  asERC20_contains: String
  asERC20_contains_nocase: String
  asERC20_not_contains: String
  asERC20_not_contains_nocase: String
  asERC20_starts_with: String
  asERC20_starts_with_nocase: String
  asERC20_not_starts_with: String
  asERC20_not_starts_with_nocase: String
  asERC20_ends_with: String
  asERC20_ends_with_nocase: String
  asERC20_not_ends_with: String
  asERC20_not_ends_with_nocase: String
  asERC20_: ERC20Contract_filter
  ERC20balances_: ERC20Balance_filter
  ERC20approvalsOwner_: ERC20Approval_filter
  ERC20approvalsSpender_: ERC20Approval_filter
  ERC20transferFromEvent_: ERC20Transfer_filter
  ERC20transferToEvent_: ERC20Transfer_filter
  events_: Event_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Account_filter]
  or: [Account_filter]
}

enum Account_orderBy {
  id
  asERC20
  asERC20__id
  asERC20__name
  asERC20__symbol
  asERC20__decimals
  asERC20__extraData
  asERC20__totalSupply
  asERC20__totalSupplyExact
  ERC20balances
  ERC20approvalsOwner
  ERC20approvalsSpender
  ERC20transferFromEvent
  ERC20transferToEvent
  events
}

enum Aggregation_interval {
  hour
  day
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

"Represents an approval for an ERC20 token\n"
type ERC20Approval {
  """Unique identifier for the approval"""
  id: ID!

  """The ERC20 token contract this approval is for"""
  contract: ERC20Contract!

  """The account that granted the approval"""
  owner: Account!

  """The account that received the approval to spend"""
  spender: Account!

  """The approved amount in decimal form"""
  value: BigDecimal!

  """The exact approved amount as a BigInt"""
  valueExact: BigInt!
}

input ERC20Approval_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  contract: String
  contract_not: String
  contract_gt: String
  contract_lt: String
  contract_gte: String
  contract_lte: String
  contract_in: [String!]
  contract_not_in: [String!]
  contract_contains: String
  contract_contains_nocase: String
  contract_not_contains: String
  contract_not_contains_nocase: String
  contract_starts_with: String
  contract_starts_with_nocase: String
  contract_not_starts_with: String
  contract_not_starts_with_nocase: String
  contract_ends_with: String
  contract_ends_with_nocase: String
  contract_not_ends_with: String
  contract_not_ends_with_nocase: String
  contract_: ERC20Contract_filter
  owner: String
  owner_not: String
  owner_gt: String
  owner_lt: String
  owner_gte: String
  owner_lte: String
  owner_in: [String!]
  owner_not_in: [String!]
  owner_contains: String
  owner_contains_nocase: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_: Account_filter
  spender: String
  spender_not: String
  spender_gt: String
  spender_lt: String
  spender_gte: String
  spender_lte: String
  spender_in: [String!]
  spender_not_in: [String!]
  spender_contains: String
  spender_contains_nocase: String
  spender_not_contains: String
  spender_not_contains_nocase: String
  spender_starts_with: String
  spender_starts_with_nocase: String
  spender_not_starts_with: String
  spender_not_starts_with_nocase: String
  spender_ends_with: String
  spender_ends_with_nocase: String
  spender_not_ends_with: String
  spender_not_ends_with_nocase: String
  spender_: Account_filter
  value: BigDecimal
  value_not: BigDecimal
  value_gt: BigDecimal
  value_lt: BigDecimal
  value_gte: BigDecimal
  value_lte: BigDecimal
  value_in: [BigDecimal!]
  value_not_in: [BigDecimal!]
  valueExact: BigInt
  valueExact_not: BigInt
  valueExact_gt: BigInt
  valueExact_lt: BigInt
  valueExact_gte: BigInt
  valueExact_lte: BigInt
  valueExact_in: [BigInt!]
  valueExact_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ERC20Approval_filter]
  or: [ERC20Approval_filter]
}

enum ERC20Approval_orderBy {
  id
  contract
  contract__id
  contract__name
  contract__symbol
  contract__decimals
  contract__extraData
  contract__totalSupply
  contract__totalSupplyExact
  owner
  owner__id
  spender
  spender__id
  value
  valueExact
}

"Represents the balance of an ERC20 token for a specific account\n"
type ERC20Balance {
  """
  Unique identifier for the balance (typically contract address + account address)
  """
  id: ID!

  """The ERC20 token contract this balance is for"""
  contract: ERC20Contract!

  """The account holding this balance"""
  account: Account

  """The balance amount in decimal form"""
  value: BigDecimal!

  """The exact balance amount as a BigInt"""
  valueExact: BigInt!

  """Transfers where this balance is the source"""
  transferFromEvent(skip: Int = 0, first: Int = 100, orderBy: ERC20Transfer_orderBy, orderDirection: OrderDirection, where: ERC20Transfer_filter): [ERC20Transfer!]!

  """Transfers where this balance is the destination"""
  transferToEvent(skip: Int = 0, first: Int = 100, orderBy: ERC20Transfer_orderBy, orderDirection: OrderDirection, where: ERC20Transfer_filter): [ERC20Transfer!]!
}

input ERC20Balance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  contract: String
  contract_not: String
  contract_gt: String
  contract_lt: String
  contract_gte: String
  contract_lte: String
  contract_in: [String!]
  contract_not_in: [String!]
  contract_contains: String
  contract_contains_nocase: String
  contract_not_contains: String
  contract_not_contains_nocase: String
  contract_starts_with: String
  contract_starts_with_nocase: String
  contract_not_starts_with: String
  contract_not_starts_with_nocase: String
  contract_ends_with: String
  contract_ends_with_nocase: String
  contract_not_ends_with: String
  contract_not_ends_with_nocase: String
  contract_: ERC20Contract_filter
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: Account_filter
  value: BigDecimal
  value_not: BigDecimal
  value_gt: BigDecimal
  value_lt: BigDecimal
  value_gte: BigDecimal
  value_lte: BigDecimal
  value_in: [BigDecimal!]
  value_not_in: [BigDecimal!]
  valueExact: BigInt
  valueExact_not: BigInt
  valueExact_gt: BigInt
  valueExact_lt: BigInt
  valueExact_gte: BigInt
  valueExact_lte: BigInt
  valueExact_in: [BigInt!]
  valueExact_not_in: [BigInt!]
  transferFromEvent_: ERC20Transfer_filter
  transferToEvent_: ERC20Transfer_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ERC20Balance_filter]
  or: [ERC20Balance_filter]
}

enum ERC20Balance_orderBy {
  id
  contract
  contract__id
  contract__name
  contract__symbol
  contract__decimals
  contract__extraData
  contract__totalSupply
  contract__totalSupplyExact
  account
  account__id
  value
  valueExact
  transferFromEvent
  transferToEvent
}

"Represents an ERC20 token contract\n"
type ERC20Contract {
  """Contract address of the ERC20 token"""
  id: Bytes!

  """Reference to the Account entity representing this contract"""
  asAccount: Account!

  """Name of the ERC20 token"""
  name: String

  """Symbol of the ERC20 token"""
  symbol: String

  """Number of decimal places for token amounts"""
  decimals: Int!

  """Additional data associated with the token"""
  extraData: String

  """Current total supply of the token"""
  totalSupply: BigDecimal!

  """Current total supply of the token"""
  totalSupplyExact: BigInt!

  """List of all balances for this token"""
  balances(skip: Int = 0, first: Int = 100, orderBy: ERC20Balance_orderBy, orderDirection: OrderDirection, where: ERC20Balance_filter): [ERC20Balance!]!

  """List of all approvals for this token"""
  approvals(skip: Int = 0, first: Int = 100, orderBy: ERC20Approval_orderBy, orderDirection: OrderDirection, where: ERC20Approval_filter): [ERC20Approval!]!

  """List of all transfers for this token"""
  transfers(skip: Int = 0, first: Int = 100, orderBy: ERC20Transfer_orderBy, orderDirection: OrderDirection, where: ERC20Transfer_filter): [ERC20Transfer!]!
}

input ERC20Contract_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  asAccount: String
  asAccount_not: String
  asAccount_gt: String
  asAccount_lt: String
  asAccount_gte: String
  asAccount_lte: String
  asAccount_in: [String!]
  asAccount_not_in: [String!]
  asAccount_contains: String
  asAccount_contains_nocase: String
  asAccount_not_contains: String
  asAccount_not_contains_nocase: String
  asAccount_starts_with: String
  asAccount_starts_with_nocase: String
  asAccount_not_starts_with: String
  asAccount_not_starts_with_nocase: String
  asAccount_ends_with: String
  asAccount_ends_with_nocase: String
  asAccount_not_ends_with: String
  asAccount_not_ends_with_nocase: String
  asAccount_: Account_filter
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  extraData: String
  extraData_not: String
  extraData_gt: String
  extraData_lt: String
  extraData_gte: String
  extraData_lte: String
  extraData_in: [String!]
  extraData_not_in: [String!]
  extraData_contains: String
  extraData_contains_nocase: String
  extraData_not_contains: String
  extraData_not_contains_nocase: String
  extraData_starts_with: String
  extraData_starts_with_nocase: String
  extraData_not_starts_with: String
  extraData_not_starts_with_nocase: String
  extraData_ends_with: String
  extraData_ends_with_nocase: String
  extraData_not_ends_with: String
  extraData_not_ends_with_nocase: String
  totalSupply: BigDecimal
  totalSupply_not: BigDecimal
  totalSupply_gt: BigDecimal
  totalSupply_lt: BigDecimal
  totalSupply_gte: BigDecimal
  totalSupply_lte: BigDecimal
  totalSupply_in: [BigDecimal!]
  totalSupply_not_in: [BigDecimal!]
  totalSupplyExact: BigInt
  totalSupplyExact_not: BigInt
  totalSupplyExact_gt: BigInt
  totalSupplyExact_lt: BigInt
  totalSupplyExact_gte: BigInt
  totalSupplyExact_lte: BigInt
  totalSupplyExact_in: [BigInt!]
  totalSupplyExact_not_in: [BigInt!]
  balances_: ERC20Balance_filter
  approvals_: ERC20Approval_filter
  transfers_: ERC20Transfer_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ERC20Contract_filter]
  or: [ERC20Contract_filter]
}

enum ERC20Contract_orderBy {
  id
  asAccount
  asAccount__id
  name
  symbol
  decimals
  extraData
  totalSupply
  totalSupplyExact
  balances
  approvals
  transfers
}

"Represents a transfer of an ERC20 token\n"
type ERC20Transfer implements Event {
  """Unique identifier for the transfer event"""
  id: ID!

  """The account that emitted this transfer event"""
  emitter: Account!

  """The transaction in which this transfer occurred"""
  transaction: Transaction!

  """The timestamp of the transfer"""
  timestamp: BigInt!

  """The ERC20 token contract involved in the transfer"""
  contract: ERC20Contract!

  """The sender's account"""
  from: Account

  """The sender's balance before the transfer"""
  fromBalance: ERC20Balance

  """The recipient's account"""
  to: Account

  """The recipient's balance after the transfer"""
  toBalance: ERC20Balance

  """The transferred amount in decimal form"""
  value: BigDecimal!

  """The exact transferred amount as a BigInt"""
  valueExact: BigInt!
}

input ERC20Transfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  emitter: String
  emitter_not: String
  emitter_gt: String
  emitter_lt: String
  emitter_gte: String
  emitter_lte: String
  emitter_in: [String!]
  emitter_not_in: [String!]
  emitter_contains: String
  emitter_contains_nocase: String
  emitter_not_contains: String
  emitter_not_contains_nocase: String
  emitter_starts_with: String
  emitter_starts_with_nocase: String
  emitter_not_starts_with: String
  emitter_not_starts_with_nocase: String
  emitter_ends_with: String
  emitter_ends_with_nocase: String
  emitter_not_ends_with: String
  emitter_not_ends_with_nocase: String
  emitter_: Account_filter
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  contract: String
  contract_not: String
  contract_gt: String
  contract_lt: String
  contract_gte: String
  contract_lte: String
  contract_in: [String!]
  contract_not_in: [String!]
  contract_contains: String
  contract_contains_nocase: String
  contract_not_contains: String
  contract_not_contains_nocase: String
  contract_starts_with: String
  contract_starts_with_nocase: String
  contract_not_starts_with: String
  contract_not_starts_with_nocase: String
  contract_ends_with: String
  contract_ends_with_nocase: String
  contract_not_ends_with: String
  contract_not_ends_with_nocase: String
  contract_: ERC20Contract_filter
  from: String
  from_not: String
  from_gt: String
  from_lt: String
  from_gte: String
  from_lte: String
  from_in: [String!]
  from_not_in: [String!]
  from_contains: String
  from_contains_nocase: String
  from_not_contains: String
  from_not_contains_nocase: String
  from_starts_with: String
  from_starts_with_nocase: String
  from_not_starts_with: String
  from_not_starts_with_nocase: String
  from_ends_with: String
  from_ends_with_nocase: String
  from_not_ends_with: String
  from_not_ends_with_nocase: String
  from_: Account_filter
  fromBalance: String
  fromBalance_not: String
  fromBalance_gt: String
  fromBalance_lt: String
  fromBalance_gte: String
  fromBalance_lte: String
  fromBalance_in: [String!]
  fromBalance_not_in: [String!]
  fromBalance_contains: String
  fromBalance_contains_nocase: String
  fromBalance_not_contains: String
  fromBalance_not_contains_nocase: String
  fromBalance_starts_with: String
  fromBalance_starts_with_nocase: String
  fromBalance_not_starts_with: String
  fromBalance_not_starts_with_nocase: String
  fromBalance_ends_with: String
  fromBalance_ends_with_nocase: String
  fromBalance_not_ends_with: String
  fromBalance_not_ends_with_nocase: String
  fromBalance_: ERC20Balance_filter
  to: String
  to_not: String
  to_gt: String
  to_lt: String
  to_gte: String
  to_lte: String
  to_in: [String!]
  to_not_in: [String!]
  to_contains: String
  to_contains_nocase: String
  to_not_contains: String
  to_not_contains_nocase: String
  to_starts_with: String
  to_starts_with_nocase: String
  to_not_starts_with: String
  to_not_starts_with_nocase: String
  to_ends_with: String
  to_ends_with_nocase: String
  to_not_ends_with: String
  to_not_ends_with_nocase: String
  to_: Account_filter
  toBalance: String
  toBalance_not: String
  toBalance_gt: String
  toBalance_lt: String
  toBalance_gte: String
  toBalance_lte: String
  toBalance_in: [String!]
  toBalance_not_in: [String!]
  toBalance_contains: String
  toBalance_contains_nocase: String
  toBalance_not_contains: String
  toBalance_not_contains_nocase: String
  toBalance_starts_with: String
  toBalance_starts_with_nocase: String
  toBalance_not_starts_with: String
  toBalance_not_starts_with_nocase: String
  toBalance_ends_with: String
  toBalance_ends_with_nocase: String
  toBalance_not_ends_with: String
  toBalance_not_ends_with_nocase: String
  toBalance_: ERC20Balance_filter
  value: BigDecimal
  value_not: BigDecimal
  value_gt: BigDecimal
  value_lt: BigDecimal
  value_gte: BigDecimal
  value_lte: BigDecimal
  value_in: [BigDecimal!]
  value_not_in: [BigDecimal!]
  valueExact: BigInt
  valueExact_not: BigInt
  valueExact_gt: BigInt
  valueExact_lt: BigInt
  valueExact_gte: BigInt
  valueExact_lte: BigInt
  valueExact_in: [BigInt!]
  valueExact_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ERC20Transfer_filter]
  or: [ERC20Transfer_filter]
}

enum ERC20Transfer_orderBy {
  id
  emitter
  emitter__id
  transaction
  transaction__id
  transaction__timestamp
  transaction__blockNumber
  timestamp
  contract
  contract__id
  contract__name
  contract__symbol
  contract__decimals
  contract__extraData
  contract__totalSupply
  contract__totalSupplyExact
  from
  from__id
  fromBalance
  fromBalance__id
  fromBalance__value
  fromBalance__valueExact
  to
  to__id
  toBalance
  toBalance__id
  toBalance__value
  toBalance__valueExact
  value
  valueExact
}

"Represents a generic event interface\n"
interface Event {
  """Unique identifier for the event"""
  id: ID!

  """The transaction in which this event occurred"""
  transaction: Transaction!

  """The account that emitted this event"""
  emitter: Account!

  """The timestamp of the event"""
  timestamp: BigInt!
}

input Event_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  emitter: String
  emitter_not: String
  emitter_gt: String
  emitter_lt: String
  emitter_gte: String
  emitter_lte: String
  emitter_in: [String!]
  emitter_not_in: [String!]
  emitter_contains: String
  emitter_contains_nocase: String
  emitter_not_contains: String
  emitter_not_contains_nocase: String
  emitter_starts_with: String
  emitter_starts_with_nocase: String
  emitter_not_starts_with: String
  emitter_not_starts_with_nocase: String
  emitter_ends_with: String
  emitter_ends_with_nocase: String
  emitter_not_ends_with: String
  emitter_not_ends_with_nocase: String
  emitter_: Account_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Event_filter]
  or: [Event_filter]
}

enum Event_orderBy {
  id
  transaction
  transaction__id
  transaction__timestamp
  transaction__blockNumber
  emitter
  emitter__id
  timestamp
}

"8 bytes signed integer\n"
scalar Int8

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Query {
  account(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    skip: Int = 0
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    where: Account_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Account!]!
  erc20Contract(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ERC20Contract
  erc20Contracts(
    skip: Int = 0
    first: Int = 100
    orderBy: ERC20Contract_orderBy
    orderDirection: OrderDirection
    where: ERC20Contract_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ERC20Contract!]!
  erc20Balance(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ERC20Balance
  erc20Balances(
    skip: Int = 0
    first: Int = 100
    orderBy: ERC20Balance_orderBy
    orderDirection: OrderDirection
    where: ERC20Balance_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ERC20Balance!]!
  erc20Approval(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ERC20Approval
  erc20Approvals(
    skip: Int = 0
    first: Int = 100
    orderBy: ERC20Approval_orderBy
    orderDirection: OrderDirection
    where: ERC20Approval_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ERC20Approval!]!
  erc20Transfer(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ERC20Transfer
  erc20Transfers(
    skip: Int = 0
    first: Int = 100
    orderBy: ERC20Transfer_orderBy
    orderDirection: OrderDirection
    where: ERC20Transfer_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ERC20Transfer!]!
  transaction(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    skip: Int = 0
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    where: Transaction_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Transaction!]!
  tokenVolume(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenVolume
  tokenVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenVolume_orderBy
    orderDirection: OrderDirection
    where: TokenVolume_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenVolume!]!
  event(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Event
  events(
    skip: Int = 0
    first: Int = 100
    orderBy: Event_orderBy
    orderDirection: OrderDirection
    where: Event_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Event!]!

  """Collection of aggregated `TokenVolumeStats` values"""
  tokenVolumeStats_collection(
    skip: Int = 0
    first: Int = 100
    interval: Aggregation_interval!
    where: TokenVolumeStats_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenVolumeStats!]!

  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Subscription {
  account(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    skip: Int = 0
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    where: Account_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Account!]!
  erc20Contract(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ERC20Contract
  erc20Contracts(
    skip: Int = 0
    first: Int = 100
    orderBy: ERC20Contract_orderBy
    orderDirection: OrderDirection
    where: ERC20Contract_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ERC20Contract!]!
  erc20Balance(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ERC20Balance
  erc20Balances(
    skip: Int = 0
    first: Int = 100
    orderBy: ERC20Balance_orderBy
    orderDirection: OrderDirection
    where: ERC20Balance_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ERC20Balance!]!
  erc20Approval(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ERC20Approval
  erc20Approvals(
    skip: Int = 0
    first: Int = 100
    orderBy: ERC20Approval_orderBy
    orderDirection: OrderDirection
    where: ERC20Approval_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ERC20Approval!]!
  erc20Transfer(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ERC20Transfer
  erc20Transfers(
    skip: Int = 0
    first: Int = 100
    orderBy: ERC20Transfer_orderBy
    orderDirection: OrderDirection
    where: ERC20Transfer_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ERC20Transfer!]!
  transaction(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    skip: Int = 0
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    where: Transaction_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Transaction!]!
  tokenVolume(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenVolume
  tokenVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenVolume_orderBy
    orderDirection: OrderDirection
    where: TokenVolume_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenVolume!]!
  event(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Event
  events(
    skip: Int = 0
    first: Int = 100
    orderBy: Event_orderBy
    orderDirection: OrderDirection
    where: Event_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Event!]!

  """Collection of aggregated `TokenVolumeStats` values"""
  tokenVolumeStats_collection(
    skip: Int = 0
    first: Int = 100
    interval: Aggregation_interval!
    where: TokenVolumeStats_filter

    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenVolumeStats!]!

  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

"A string representation of microseconds UNIX timestamp (16 digits)\n"
scalar Timestamp

"Represents the volume of a token over time\n"
type TokenVolume {
  """Unique identifier for the TokenVolume"""
  id: Int8!

  """The timestamp of the volume measurement"""
  timestamp: Timestamp!

  """The Token this volume is for"""
  token: ERC20Contract!

  """The number of transfers in this time period"""
  transferCount: Int!

  """The volume of the token transferred"""
  volume: BigInt!
}

"Represents aggregated statistics for token volume\n"
type TokenVolumeStats {
  """Unique identifier for the TokenVolumeStats"""
  id: Int8!

  """The timestamp of the aggregation"""
  timestamp: Timestamp!

  """The token this aggregation is for"""
  token: ERC20Contract!

  """The total number of transfers in the aggregation period"""
  totalTransfers: Int!

  """The total volume for the aggregation period"""
  totalVolume: BigInt!
}

input TokenVolumeStats_filter {
  id: Int8
  id_gt: Int8
  id_lt: Int8
  id_gte: Int8
  id_lte: Int8
  id_in: [Int8!]
  timestamp: Timestamp
  timestamp_gt: Timestamp
  timestamp_lt: Timestamp
  timestamp_gte: Timestamp
  timestamp_lte: Timestamp
  timestamp_in: [Timestamp!]
  token: String
  token_: ERC20Contract_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TokenVolumeStats_filter]
  or: [TokenVolumeStats_filter]
}

input TokenVolume_filter {
  id: Int8
  id_not: Int8
  id_gt: Int8
  id_lt: Int8
  id_gte: Int8
  id_lte: Int8
  id_in: [Int8!]
  id_not_in: [Int8!]
  timestamp: Timestamp
  timestamp_not: Timestamp
  timestamp_gt: Timestamp
  timestamp_lt: Timestamp
  timestamp_gte: Timestamp
  timestamp_lte: Timestamp
  timestamp_in: [Timestamp!]
  timestamp_not_in: [Timestamp!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: ERC20Contract_filter
  transferCount: Int
  transferCount_not: Int
  transferCount_gt: Int
  transferCount_lt: Int
  transferCount_gte: Int
  transferCount_lte: Int
  transferCount_in: [Int!]
  transferCount_not_in: [Int!]
  volume: BigInt
  volume_not: BigInt
  volume_gt: BigInt
  volume_lt: BigInt
  volume_gte: BigInt
  volume_lte: BigInt
  volume_in: [BigInt!]
  volume_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TokenVolume_filter]
  or: [TokenVolume_filter]
}

enum TokenVolume_orderBy {
  id
  timestamp
  token
  token__id
  token__name
  token__symbol
  token__decimals
  token__extraData
  token__totalSupply
  token__totalSupplyExact
  transferCount
  volume
}

"Represents a transaction on the blockchain\n"
type Transaction {
  """Transaction hash"""
  id: ID!

  """Timestamp of the transaction"""
  timestamp: BigInt!

  """Block number in which the transaction was included"""
  blockNumber: BigInt!

  """List of events emitted in this transaction"""
  events(skip: Int = 0, first: Int = 100, orderBy: Event_orderBy, orderDirection: OrderDirection, where: Event_filter): [Event!]!
}

input Transaction_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  events_: Event_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Transaction_filter]
  or: [Transaction_filter]
}

enum Transaction_orderBy {
  id
  timestamp
  blockNumber
  events
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes

  """The block number"""
  number: Int!

  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int

  """The hash of the parent block"""
  parentHash: Bytes
}

"""The type for the top-level _meta field"""
type _Meta_ {
  "Information about a specific subgraph block. The hash of the block\nwill be null if the _meta field has a block constraint that asks for\na block number. It will be filled if the _meta field has no block constraint\nand therefore asks for the latest  block\n"
  block: _Block_!

  """The deployment ID"""
  deployment: String!

  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}